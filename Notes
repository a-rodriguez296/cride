En config settings local es donde está toda la configuración inicial del proyecto. 
Ahi es donde está que la aplicación de django se llama cride

Siempre es importante revisar local.py y production.py pq ahi es donde está la configuración de los ambientes 
(local y prod)

Pilas con el archivo local.yml. Ahi también hay cosas que tienen q ver con el nombre del proyecto.


==========================================================

Instrucciones Docker:

Para no tener que siempre poner en los comandos -f local.yml escribir el siguiente comando
export COMPOSE_FILE=local.yml

Que es lo que hay que hacer para que esto corra:
Crear una imagen (esto según entiendo crea el entorno (baja las dependencias, crea la base de datos, el django, etc))
y luego correr el docker 

docker-compose build (crea la imagen)
docker-compose up (correr el docker)

Con el comando docker-compose ps se pueden ver los contenedores que están activos


PARA HACER DEBUG DE django
Hacer up para correr los contenedores
Para django 
y luego ejecutarlo en una sesión diferente

docker-compose up 
docker rm -f cride-platzi_django_1 (nombre del contenedor de django)
docker-compose run --rm --service-ports django (esto se debe hacer en otro tab del terminal)


========================================================

al parecer con esta herramienta se puede crear el template del proyecto
https://github.com/agconti/cookiecutter-django-rest


==================================================
cada vez que se crea un app interna lo que hay q hacer es crear el folder
un __init__.py y listo

en el apps.py hay que crear la clase mínimo con name y verbose_name. Son requeridos esos dos


Luego en el archivo de configuración, que es config/settings/base.py, hay que agregar el app en la variable  LOCAL_APPS
Siempre cuando se crea un modelo, hay que crear el folder de migrations con el respectivo __init__.py 


=========================================================
Para el tema de los usuarios customized.

Se crea el modulo como lo cree acá
Se crea el archivo models y la clase user que hereda de AbstractUser.

Luego el tema es que este user entra en conflicto con la tabla User que django ya tiene creada en la BD 

Por tal motivo lo que hay que hacer es borrar la base de datos (para que se borre la tabla User de django)
y ejecutar el proyecto de nuevo

PAra borrar hay que parar los servicios 
docker-compose down
docker volume ls (Sirve para listar los volumenes (las bases de datos?))
docker volume rm XYZ_local_postgres_data (este es el archivo de la base de datos)

Luego hay que crear el super user 
Para ello hay que hacer las migraciones en django 
docker-compose run --rm django python manage.py makemigrations



===============================================================
PAra no tener que hacer una nueva migración (acabo de crear el profile), lo que se puede hacer es 
borrar la migración actual y hacer de nuevo los pasos de eliminar la base de datos actual,
makemigrations y migrate


lo que se debe hacer es:
Incluir el nuevo modelo en models/__init__.py 
hacer down
borrar el volumen 
docker-compose run --rm django python manage.py makemigrations
docker-compose run --rm django python manage.py migrate 

Luego se vuelve a crear el superuser 
docker-compose run --rm django python manage.py createsuperuser

===============================================================

Para crear una app nueva lo que hay que hacer es 
Crear un folder nuevo 
crear el subfolder migrations con su __init__.py 
crear el archivo models
Y el MÁS IMPORTANTE crear apps.py (Ver el contenido del archivo)

Es MUY IMPORTANTE actualizar el archivo base.py PILAS

===============================================================
Para añadir info automaticamente a la DB se debe crear un archivo json con la data 
y luego se debe ejecutar el archivo loadData con la dirección del archivo donde esta el json 


docker-compose run --rm django python manage.py loaddata cride/circles/circles.json

===============================================================
Es muy importante recordar que cuando se instala una extension como
django rest framework, hay que agregarla en THIRD_PARTY_APPS en config/settings/base.py

para hacer las pruebas más faciles se puede utilizar un librería que se llama httpie
brew install httpie

con esto ya se pueden hacer requests desde la terminal 
http localhost:8000/circles/ -b

===============================================================
Para probar el serializer se puede probar en shell_plus

from cride.circles.serializers import CircleSerializer
circle = Circle.objects.latest()

from cride.circles.serializers import CircleSerializer
serializer = CircleSerializer(circle)
serializer.data


Los serializadores son como un form y hay que crear la clase casi igual.

class CreateCircleSerializer(serializers.Serializer):
    name = serializers.CharField(max_length=140)
    slug_name = serializers.SlugField(
        max_length=40,
        validators=[
            UniqueValidator(queryset=Circle.objects.all())
        ]
        )
    about = serializers.CharField(
        max_length=255,
        required=False
    )

    def create(self, data):
        return Circle.objects.create(**data)

Dentro de la clase es importante crear el metodo create que es el que al final guarda en la base de datos
lo que llega. 

También se pueden incluir los validadores para VALIDAR DUHHH los datos 

En la parte de la vista, termina siendo asi 

def create_circle(request):
    serializer = CreateCircleSerializer(data=request.data)
    serializer.is_valid(raise_exception=True)
    circle = serializer.save()
    return Response(CircleSerializer(circle).data)

  ===============================================================

  En este commit estoy haciendo el login para el api 

  Lo primero que hice fue crear el enrutador en config/urls y ponerlo a apuntar a crides/users/urls.py 

  Ahi se hace el manejo para indicar que la vista que va a hacer el manejo es UserLoginAPIView

  Una vez en UserLoginAPIView, se crea el serializer UserLoginSerializer, que es quien se encarga de validar la data 

  En el método validate de  UserLoginSerializer, es donde se hace la autenticación del usuario 




